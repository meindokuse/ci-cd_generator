stages:
  - build
  - test
  - lint
  - sonarqube
  - security
  - integration
  - deploy

# ========== ENVIRONMENT VARIABLES ==========
variables:
  # Non-sensitive environment variables
  ENV: "dev"
  KAFKA_BROKERS: "kafka:9092"
  KAFKA_TOPIC: "orders"
  KAFKA_GROUP: "order-service"
  HTTP_ADDR: ":8080"

  # Sensitive variables (passwords, secrets, keys) should be set in:
  # GitLab â†’ Settings â†’ CI/CD â†’ Variables
  # See GITLAB_VARIABLES.md for details

# ========== CI/CD VARIABLES ==========
variables:
  DOCKER_IMAGE_TAG: "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHA"
  DOCKER_IMAGE_LATEST: "$CI_REGISTRY_IMAGE:latest"
  SSH_PORT: "22"
  DEPLOY_ENV: "production"
  SONAR_HOST_URL: "http://sonarqube:9000"

# ========== BUILD STAGE ==========
build:
  stage: build
  image: docker:24-cli
  services:
    - docker:24-dind
  variables:
    DOCKER_DRIVER: overlay2
    DOCKER_TLS_CERTDIR: "/certs"
  before_script:
    - echo "ðŸ” Logging into Docker Registry..."
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - echo "ðŸ—ï¸  Building Docker image..."
    - docker build --build-arg ENV=$ENV --build-arg DB_HOST=$DB_HOST --build-arg DB_PORT=$DB_PORT --build-arg DB_USER=$DB_USER --build-arg DB_PASSWORD=$DB_PASSWORD --build-arg DB_NAME=$DB_NAME --build-arg KAFKA_BROKERS=$KAFKA_BROKERS --build-arg KAFKA_TOPIC=$KAFKA_TOPIC --build-arg KAFKA_GROUP=$KAFKA_GROUP --build-arg HTTP_ADDR=$HTTP_ADDR --build-arg POSTGRES_USER=$POSTGRES_USER --build-arg POSTGRES_PASSWORD=$POSTGRES_PASSWORD --build-arg POSTGRES_DB=$POSTGRES_DB -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA -t $CI_REGISTRY_IMAGE:latest .
    - echo "ðŸ“¤ Pushing to Docker Registry..."
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - docker push $CI_REGISTRY_IMAGE:latest
    - echo "âœ… Docker image stored in registry"
  only:
    - main
  tags:
    - docker
  retry:
    max: 2

# ========== TEST STAGE ==========
test:
  stage: test
  image: python:1.24.6-alpine
  script:
    - pytest
  after_script:

    - rm -f coverage.out || true
    - rm -rf test-reports || true
    - echo 'Go test cleanup done'
  tags:
    - docker
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure
  artifacts:
    paths:

      - coverage.out
      - test-reports/
    expire_in: 1 week

# ========== LINT STAGE ==========
lint:
  stage: lint
  image: golang:1.24.6-alpine
  before_script:
    - echo "================================================"
    - echo "LINT STAGE - Go 1.24.6"
    - echo "================================================"
    - echo "ðŸ“¦ Installing golangci-lint..."
    - apk add --no-cache git
    - go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
  script:
    - echo ""
    - echo "ðŸ” Running golangci-lint (comprehensive Go linter)..."
    - $GOPATH/bin/golangci-lint run ./... --timeout=5m || true
    - echo ""
    - echo "ðŸ” Running go vet (official Go tool)..."
    - go vet ./... || true
    - echo ""
    - echo "ðŸ” Running go fmt check..."
    - test -z $(gofmt -l .) || (echo "Code not formatted!" && gofmt -d . && exit 1) || true
    - echo ""
    - echo "âœ… Lint stage completed!"
  allow_failure: true
  only:
    - main
    - merge_requests
  tags:
    - docker

# ========== SONARQUBE STAGE ==========
sonarqube:
  stage: sonarqube
  image: sonarsource/sonar-scanner-cli:latest
  variables:
    SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"
    GIT_DEPTH: "0"
  before_script:
    - echo "================================================"
    - echo "SONARQUBE ANALYSIS - go 1.24.6"
    - echo "================================================"
    - echo "ðŸ” SonarQube will automatically detect and analyze:"
    - echo "   âœ“ Programming languages"
    - echo "   âœ“ Frameworks (Django, Spring, React, etc.)"
    - echo "   âœ“ Libraries and dependencies"
    - echo "   âœ“ Security vulnerabilities (CVE)"
    - echo "   âœ“ Code quality issues"
    - echo "   âœ“ Technical debt"
    - echo ""
  script:
    - echo "ðŸ” Starting SonarQube Scanner..."
    - echo ""

    # Ð—Ð°Ð¿ÑƒÑÐº SonarQube Ñ Ð²Ñ‹Ð²Ð¾Ð´Ð¾Ð¼
    - sonar-scanner
      -Dsonar.projectKey=$CI_PROJECT_NAME
      -Dsonar.projectName="$CI_PROJECT_NAME"
      -Dsonar.projectVersion=$CI_COMMIT_SHORT_SHA
      -Dsonar.sources=.
      -Dsonar.host.url=$SONAR_HOST_URL
      -Dsonar.login=$SONAR_TOKEN
      -Dsonar.verbose=false
      -Dsonar.language=go
      -Dsonar.sources=.
      -Dsonar.exclusions=**/*_test.go,**/vendor/**
      -Dsonar.go.coverage.reportPaths=coverage.out
      -Dsonar.go.tests.reportPaths=test-report.json

    - echo ""
    - echo "âœ… SonarQube analysis completed!"
    - echo ""

    # ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ñ€ÐµÐ°Ð»ÑŒÐ½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð¸Ð· SonarQube API
    - echo "ðŸ“Š FETCHING PROJECT ANALYSIS RESULTS..."
    - echo ""

    # Ð£ÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ° curl Ð¸ jq Ð´Ð»Ñ Ð¿Ð°Ñ€ÑÐ¸Ð½Ð³Ð° JSON
    - apk add --no-cache curl jq

    # ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ð¼ÐµÑ‚Ñ€Ð¸ÐºÐ¸ Ð¿Ñ€Ð¾ÐµÐºÑ‚Ð° Ñ‡ÐµÑ€ÐµÐ· API
    - |
      echo "ðŸ” Detected Technologies and Stack:"
      echo ""

      # ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ð¾ÑÐ½Ð¾Ð²Ð½Ñ‹Ðµ Ð¼ÐµÑ‚Ñ€Ð¸ÐºÐ¸
      METRICS=$(curl -s -u $SONAR_TOKEN: "$SONAR_HOST_URL/api/measures/component?component=$CI_PROJECT_NAME&metricKeys=ncloc,files,functions,classes,complexity,vulnerabilities,bugs,code_smells,coverage,duplicated_lines_density")

      # ÐŸÐ°Ñ€ÑÐ¸Ð¼ Ð¸ Ð²Ñ‹Ð²Ð¾Ð´Ð¸Ð¼
      NCLOC=$(echo $METRICS | jq -r '.component.measures[] | select(.metric=="ncloc") | .value')
      FILES=$(echo $METRICS | jq -r '.component.measures[] | select(.metric=="files") | .value')
      FUNCTIONS=$(echo $METRICS | jq -r '.component.measures[] | select(.metric=="functions") | .value')
      CLASSES=$(echo $METRICS | jq -r '.component.measures[] | select(.metric=="classes") | .value')
      COMPLEXITY=$(echo $METRICS | jq -r '.component.measures[] | select(.metric=="complexity") | .value')
      VULNERABILITIES=$(echo $METRICS | jq -r '.component.measures[] | select(.metric=="vulnerabilities") | .value')
      BUGS=$(echo $METRICS | jq -r '.component.measures[] | select(.metric=="bugs") | .value')
      CODE_SMELLS=$(echo $METRICS | jq -r '.component.measures[] | select(.metric=="code_smells") | .value')
      COVERAGE=$(echo $METRICS | jq -r '.component.measures[] | select(.metric=="coverage") | .value')
      DUPLICATIONS=$(echo $METRICS | jq -r '.component.measures[] | select(.metric=="duplicated_lines_density") | .value')

      echo "ðŸ“ˆ CODE METRICS:"
      echo "   Lines of Code: $NCLOC"
      echo "   Files: $FILES"
      echo "   Functions: $FUNCTIONS"
      echo "   Classes: $CLASSES"
      echo "   Complexity: $COMPLEXITY"
      echo ""

      echo "ðŸ› ISSUES FOUND:"
      echo "   Vulnerabilities: $VULNERABILITIES"
      echo "   Bugs: $BUGS"
      echo "   Code Smells: $CODE_SMELLS"
      echo ""

      echo "ðŸ“Š QUALITY METRICS:"
      echo "   Coverage: $COVERAGE%"
      echo "   Duplications: $DUPLICATIONS%"
      echo ""

    # ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ ÑÐ¿Ð¸ÑÐ¾Ðº ÑÐ·Ñ‹ÐºÐ¾Ð² Ð¿Ñ€Ð¾ÐµÐºÑ‚Ð°
    - |
      echo "ðŸ’» DETECTED LANGUAGES:"
      LANGUAGES=$(curl -s -u $SONAR_TOKEN: "$SONAR_HOST_URL/api/measures/component?component=$CI_PROJECT_NAME&metricKeys=ncloc_language_distribution")

      echo $LANGUAGES | jq -r '.component.measures[] | select(.metric=="ncloc_language_distribution") | .value' | tr ';' '\n' | while read line; do
        echo "   â€¢ $line"
      done
      echo ""

    # ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ ÑÐ¿Ð¸ÑÐ¾Ðº issues (Ñ€ÐµÐ°Ð»ÑŒÐ½Ñ‹Ðµ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ñ‹)
    - |
      echo "ðŸ”’ SECURITY & QUALITY ISSUES:"
      ISSUES=$(curl -s -u $SONAR_TOKEN: "$SONAR_HOST_URL/api/issues/search?componentKeys=$CI_PROJECT_NAME&ps=5&types=VULNERABILITY,BUG&severities=CRITICAL,MAJOR")

      echo $ISSUES | jq -r '.issues[] | "   â€¢ [\(.severity)] \(.message) (\(.component | split(\":\")[1]):\(.line))"' | head -10
      echo ""

    # Ð¡ÑÑ‹Ð»ÐºÐ° Ð½Ð° Ð¿Ð¾Ð»Ð½Ñ‹Ð¹ Ð¾Ñ‚Ñ‡ÐµÑ‚
    - echo "================================================"
    - echo "ðŸ“Š FULL DETAILED REPORT:"
    - echo "   ðŸ‘‰ $SONAR_HOST_URL/dashboard?id=$CI_PROJECT_NAME"
    - echo ""
    - echo "This report includes:"
    - echo "   â€¢ Complete technology stack detection"
    - echo "   â€¢ All detected frameworks and libraries"
    - echo "   â€¢ Security vulnerabilities with CVE references"
    - echo "   â€¢ Code quality breakdown by file"
    - echo "   â€¢ Technical debt estimation"
    - echo "================================================"

  after_script:
    - echo ""
    - echo "================================================"
    - echo "SONARQUBE ANALYSIS COMPLETE"
    - echo "================================================"
    - echo "Project: $CI_PROJECT_NAME"
    - echo "Version: $CI_COMMIT_SHORT_SHA"
    - echo ""
    - echo "ðŸ”— View full analysis:"
    - echo "   $SONAR_HOST_URL/dashboard?id=$CI_PROJECT_NAME"
    - echo "================================================"

  allow_failure: true
  only:
    - main
    - merge_requests
  tags:
    - docker
  cache:
    key: "${CI_COMMIT_REF_SLUG}-sonar"
    paths:
      - .sonar/cache

# ========== SECURITY STAGE ==========
security:
  stage: security
  image: golang:1.24.6-alpine
  before_script:
    - echo "================================================"
    - echo "SECURITY STAGE - Go 1.24.6"
    - echo "================================================"
    - echo "ðŸ“¦ Installing gosec (security scanner)..."
    - go install github.com/securego/gosec/v2/cmd/gosec@latest
  script:
    - echo ""
    - echo "ðŸ”’ Running gosec (Go security checker)..."
    - $GOPATH/bin/gosec -fmt=json -out=gosec-report.json ./... || true
    - $GOPATH/bin/gosec ./... || true
    - echo ""
    - echo "âœ… Security scan completed!"
  artifacts:
    reports:
      sast: gosec-report.json
    expire_in: 1 week
  allow_failure: true
  only:
    - main
    - merge_requests
  tags:
    - docker

security_docker:
  stage: security
  image: aquasec/trivy:latest
  before_script:
    - echo "================================================"
    - echo "DOCKER IMAGE SECURITY SCAN"
    - echo "================================================"
  script:
    - echo ""
    - echo "ðŸ”’ Scanning Docker image with Trivy..."
    - trivy image --exit-code 0 --severity HIGH,CRITICAL --format table $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - echo ""
    - echo "ðŸ”’ Generating JSON report..."
    - trivy image --exit-code 0 --severity HIGH,CRITICAL --format json --output trivy-report.json $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA || true
    - echo ""
    - echo "âœ… Docker image scan completed!"
  artifacts:
    paths:
      - trivy-report.json
    expire_in: 1 week
  allow_failure: true
  only:
    - main
  tags:
    - docker


# ========== DEPLOY STAGE ==========
deploy_production:
  stage: deploy
  image: alpine:latest
  before_script:
    - echo "================================================"
    - echo "DEPLOY STAGE - Docker Registry â†’ Server"
    - echo "================================================"
    - apk add --no-cache openssh-client docker-cli docker-compose
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - ssh-keyscan -H $SSH_HOST >> ~/.ssh/known_hosts 2>/dev/null
  script:
    - echo ""
    - echo "ðŸ³ Generating docker-compose.prod.yml..."
    - |
      cat > docker-compose.prod.yml << 'COMPOSE_EOF'
      version: "3.9"
      services:

        app:
          image: ${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHA}
          restart: unless-stopped
          ports:
            - "3000:3000"

          environment:

            - ENV=$ENV

            - DB_HOST=$DB_HOST

            - DB_PORT=$DB_PORT

            - DB_USER=$DB_USER

            - DB_PASSWORD=$DB_PASSWORD

            - DB_NAME=$DB_NAME

            - KAFKA_BROKERS=$KAFKA_BROKERS

            - KAFKA_TOPIC=$KAFKA_TOPIC

            - KAFKA_GROUP=$KAFKA_GROUP

            - HTTP_ADDR=$HTTP_ADDR

            - POSTGRES_USER=$POSTGRES_USER

            - POSTGRES_PASSWORD=$POSTGRES_PASSWORD

            - POSTGRES_DB=$POSTGRES_DB



      COMPOSE_EOF

    - echo ""
    - echo "ðŸ“¤ Uploading docker-compose.prod.yml to server..."
    - scp -P ${SSH_PORT:-22} docker-compose.prod.yml $SSH_USER@$SSH_HOST:/app/docker-compose.yml

    - echo ""
    - echo "ðŸ“ Creating .env file..."
    - |
      cat > .env.deploy << 'ENV_EOF'
      CI_REGISTRY_IMAGE=$CI_REGISTRY_IMAGE
      CI_COMMIT_SHA=$CI_COMMIT_SHA

      # Runtime environment variables

      ENV=$ENV

      DB_HOST=$DB_HOST

      DB_PORT=$DB_PORT

      DB_USER=$DB_USER

      DB_PASSWORD=$DB_PASSWORD

      DB_NAME=$DB_NAME

      KAFKA_BROKERS=$KAFKA_BROKERS

      KAFKA_TOPIC=$KAFKA_TOPIC

      KAFKA_GROUP=$KAFKA_GROUP

      HTTP_ADDR=$HTTP_ADDR

      POSTGRES_USER=$POSTGRES_USER

      POSTGRES_PASSWORD=$POSTGRES_PASSWORD

      POSTGRES_DB=$POSTGRES_DB


      ENV_EOF
    - scp -P ${SSH_PORT:-22} .env.deploy $SSH_USER@$SSH_HOST:/app/.env

    - echo ""
    - echo "ðŸš€ Deploying on server..."
    - |
      ssh -p ${SSH_PORT:-22} $SSH_USER@$SSH_HOST << 'REMOTE_SCRIPT'
      cd /app
      export $(cat .env | xargs)
      docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
      docker-compose pull
      docker-compose up -d
      docker image prune -f
      echo "âœ… Deploy complete!"
      REMOTE_SCRIPT

  environment:
    name: production
    url: http://$SSH_HOST
  only:
    - main
  when: manual
  tags:
    - docker

